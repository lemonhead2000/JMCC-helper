import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import { LanguageClient, LanguageClientOptions, ServerOptions, Executable } from 'vscode-languageclient/node';
import * as https from 'https';
import { spawn } from 'child_process';

const TERMINAL_NAME = 'JMCC Terminal';
let client: LanguageClient | undefined;

async function checkAndUpdateAssets(context: vscode.ExtensionContext) {
  const assetsDir = context.asAbsolutePath('out/assets');
  const jmccDir = context.asAbsolutePath('out/JMCC');
  if (!fs.existsSync(assetsDir)) fs.mkdirSync(assetsDir, { recursive: true });
  if (!fs.existsSync(jmccDir)) fs.mkdirSync(jmccDir, { recursive: true });

  const REMOTE_PROPS_URL = 'https://raw.githubusercontent.com/donzgold/JustMC_compilator/master/jmcc.properties';
  const COMPLETIONS_URL = 'https://raw.githubusercontent.com/donzgold/JustMC_compilator/master/assets/completions.json';
  const HOVER_URL = 'https://raw.githubusercontent.com/donzgold/JustMC_compilator/master/assets/hover.json';
  const JMCC_PY_URL = 'https://raw.githubusercontent.com/donzgold/JustMC_compilator/master/jmcc.py';

  async function download(url: string): Promise<string | null> {
    return new Promise(resolve => {
      https.get(url.trim(), res => {
        if (res.statusCode !== 200) return resolve(null);
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => resolve(data));
      }).on('error', err => {
        console.error('Download error:', err);
        resolve(null);
      });
    });
  }

  function extractDataVersion(content: string): string | null {
    const match = content.match(/^\s*data_version\s*=\s*(\S+)/m);
    return match ? match[1].trim() : null;
  }

  function upsertProp(lines: string[], key: string, value: string): string[] {
    const re = new RegExp(`^\\s*(#\\s*)?${key}\\s*=`, 'i');
    let found = false;
    const updated = lines.map(line => {
      if (re.test(line)) {
        found = true;
        return `${key} = ${value}`;
      }
      return line;
    });
    if (!found) {
      updated.push(`${key} = ${value}`);
    }
    return updated;
  }

  async function waitForFile(filePath: string, timeoutMs: number = 3000): Promise<boolean> {
    const start = Date.now();
    return new Promise(resolve => {
      const check = () => {
        if (fs.existsSync(filePath)) return resolve(true);
        if (Date.now() - start > timeoutMs) return resolve(false);
        setTimeout(check, 100);
      };
      check();
    });
  }

  const files = [
    { url: COMPLETIONS_URL, path: path.join(assetsDir, 'completions.json') },
    { url: HOVER_URL, path: path.join(assetsDir, 'hover.json') },
    { url: JMCC_PY_URL, path: path.join(jmccDir, 'jmcc.py') }
  ];

  for (const file of files) {
    const content = await download(file.url);
    if (content) {
      fs.writeFileSync(file.path, content, 'utf8');
      console.log(`Downloaded: ${file.path}`);
    }
  }

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) return;

  const config = loadOrInitConfig(workspaceFolder);
  const compilerPath = getCompilerPath(context, config);
  const compilerDir = path.dirname(compilerPath);
  const userPropsPath = path.join(compilerDir, 'jmcc.properties');

  const REMOTE_PROPS_CONTENT = await download(REMOTE_PROPS_URL);
  if (!REMOTE_PROPS_CONTENT) return;
  const remoteDataVersion = extractDataVersion(REMOTE_PROPS_CONTENT);
  if (!remoteDataVersion) return;

  const propsExistedBefore = fs.existsSync(userPropsPath);
  if (!propsExistedBefore) {
    vscode.window.showInformationMessage('JMCC: Инициализация компилятора... Запуск jmcc.py');

    const pythonCommand = os.platform() === 'win32' ? 'py' : 'python3';
    try {
      await new Promise<void>((resolve, reject) => {
        const child = spawn(pythonCommand, [compilerPath], {
          cwd: compilerDir,
          stdio: 'pipe',
          shell: false
        });

        let stderrData = '';
        let stdoutData = '';

        child.stderr.on('data', data => stderrData += data.toString());
        child.stdout.on('data', data => stdoutData += data.toString());

        child.on('close', async (code) => {
          const exists = fs.existsSync(userPropsPath) || await waitForFile(userPropsPath);

          if (!exists) {
            fs.writeFileSync(
              userPropsPath,
              `# Auto-generated by JMCC extension\n`,
              'utf8'
            );
          }

          if (exists) {
            let content = fs.readFileSync(userPropsPath, 'utf8');
            let lines = content.split(/\r?\n/);

            lines = upsertProp(lines, 'auto_update', 'True');
            lines = upsertProp(lines, 'check_beta_versions', 'True');
            lines = upsertProp(lines, 'data_version', remoteDataVersion);

            fs.writeFileSync(userPropsPath, lines.join('\n'), 'utf8');
            vscode.window.showInformationMessage('JMCC: Компилятор успешно инициализирован и настроен.');
          }

          if (code === 0) {
            console.log('jmcc.py executed successfully.');
            console.log('stdout:', stdoutData);
            resolve();
          } else {
            console.error(`jmcc.py failed with code ${code}`);
            console.error('stderr:', stderrData);
            reject();
          }
        });

        child.on('error', err => {
          console.error('Spawn error:', err);
          reject();
        });
      });
    } catch (err) {
      vscode.window.showWarningMessage('JMCC: Не удалось инициализировать компилятор. Функции автодополнения могут быть ограничены.');
    }
  }

  if (fs.existsSync(userPropsPath)) {
    const localContent = fs.readFileSync(userPropsPath, 'utf8');
    const localDataVersion = extractDataVersion(localContent);
    if (localDataVersion !== remoteDataVersion) {
      const contentCompletions = await download(COMPLETIONS_URL);
      const contentHover = await download(HOVER_URL);
      if (contentCompletions) {
        fs.writeFileSync(path.join(assetsDir, 'completions.json'), contentCompletions, 'utf8');
      }
      if (contentHover) {
        fs.writeFileSync(path.join(assetsDir, 'hover.json'), contentHover, 'utf8');
      }

      let lines = localContent.split(/\r?\n/);
      lines = upsertProp(lines, 'data_version', remoteDataVersion);
      fs.writeFileSync(userPropsPath, lines.join('\n'), 'utf8');
    }
  }
}


function getServerOptions(context: vscode.ExtensionContext): ServerOptions {
    const pythonCommand = os.platform() === 'win32' ? 'py' : 'python3';
    const serverModule = context.asAbsolutePath(path.join('out', 'server.py'));
    const run: Executable = {
        command: pythonCommand,
        args: [serverModule],
        options: { cwd: context.extensionPath }
    };
    const debug: Executable = {
        command: pythonCommand,
        args: [serverModule],
        options: { cwd: context.extensionPath }
    };
    return { run, debug };
}

function getClientOptions(): LanguageClientOptions {
    const outputChannel = vscode.window.createOutputChannel('JMCC Language Server');
    return {
        documentSelector: [{ scheme: 'file', language: 'justcode' }],
        synchronize: {
            fileEvents: vscode.workspace.createFileSystemWatcher('**/*.jc')
        },
        outputChannel: outputChannel,
        outputChannelName: 'JMCC Language Server'
    };
}

function getOrCreateTerminal(): vscode.Terminal {
    const existing = vscode.window.terminals.find(t => t.name === TERMINAL_NAME);
    return existing ?? vscode.window.createTerminal(TERMINAL_NAME);
}

function getConfigPath(workspaceFolder: vscode.WorkspaceFolder): string {
    const configDir = path.join(workspaceFolder.uri.fsPath, '.vscode');
    if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
    }
    return path.join(configDir, '.jmccconfig.json');
}

function loadOrInitConfig(workspaceFolder: vscode.WorkspaceFolder): any {
    const configPath = getConfigPath(workspaceFolder);
    if (!fs.existsSync(configPath)) {
        const defaultConfig = {
            compilerPath: "",
            defaultCompileActiveFileMode: "UPLOAD",
            compilerOutputPath: "",
            clearTerminalBeforeCommand: true
        };
        fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2), 'utf-8');
    }
    let config;
    try {
        config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    } catch (err) {
        vscode.window.showErrorMessage('JMCC: Ошибка чтения .jmccconfig.json. Проверьте формат JSON.');
        throw err;
    }
    let modified = false;
    if (!config.defaultCompileActiveFileMode) {
        config.defaultCompileActiveFileMode = 'UPLOAD';
        modified = true;
    } else if (config.defaultCompileActiveFileMode.toUpperCase() === 'FILE') {
        config.defaultCompileActiveFileMode = 'SAVE';
        modified = true;
    }
    if (!config.compilerOutputPath) {
        config.compilerOutputPath = '';
        modified = true;
    }
    if (config.clearTerminalBeforeCommand === undefined) {
        config.clearTerminalBeforeCommand = true;
        modified = true;
    }
    if (modified) {
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
    }
    return config;
}

function getWorkspaceFolder(fileUri: vscode.Uri): vscode.WorkspaceFolder | undefined {
    return vscode.workspace.getWorkspaceFolder(fileUri);
}

function runCommand(command: string, workspaceFolder: vscode.WorkspaceFolder) {
    const config = loadOrInitConfig(workspaceFolder);
    const terminal = getOrCreateTerminal();
    terminal.show();
    if (config.clearTerminalBeforeCommand !== false) {
        terminal.sendText(os.platform() === 'win32' ? 'cls' : 'clear');
    }
    terminal.sendText(command);
}

function validatePath(filePath: string, isFile: boolean = false): boolean {
    try {
        if (!fs.existsSync(filePath)) return false;
        const stat = fs.statSync(filePath);
        if (isFile && stat.isDirectory()) return false;
        return true;
    } catch (err) {
        return false;
    }
}

function getCompilerPath(context: vscode.ExtensionContext, config: any): string {
    if (config.compilerPath && config.compilerPath.trim() !== '') {
        return path.normalize(config.compilerPath);
    }
    return context.asAbsolutePath(path.join('out', 'JMCC', 'jmcc.py'));
}

function compile(targetPath: string, mode: string, workspaceFolder: vscode.WorkspaceFolder, context: vscode.ExtensionContext, isCompileAsFile: boolean = false) {
    const config = loadOrInitConfig(workspaceFolder);
    const compilerPath = getCompilerPath(context, config);
    if (config.compilerPath && config.compilerPath.trim() !== '') {
        if (!validatePath(compilerPath)) {
            vscode.window.showErrorMessage(`JMCC: Путь к компилятору недействителен: ${compilerPath}`);
            return;
        }
    }
    const args = ['py', `"${compilerPath}"`, 'compile', `"${path.normalize(targetPath)}"`];
    if (mode === 'UPLOAD') {
        args.push('-u');
    } else if (mode === 'BOTH') {
        args.push('-su');
    }
    if ((mode === 'SAVE' || mode === 'BOTH' || isCompileAsFile) && config.compilerOutputPath && config.compilerOutputPath.trim() !== '') {
        const normalizedOutputPath = path.normalize(config.compilerOutputPath);
        if (!validatePath(normalizedOutputPath, true)) {
            vscode.window.showErrorMessage(`JMCC: Путь для вывода должен быть файлом: ${normalizedOutputPath}`);
            return;
        }
        args.push('-o', `"${normalizedOutputPath}"`);
    }
    runCommand(args.join(' '), workspaceFolder);
}

function decompile(targetPath: string, workspaceFolder: vscode.WorkspaceFolder, context: vscode.ExtensionContext) {
    const config = loadOrInitConfig(workspaceFolder);
    const compilerPath = getCompilerPath(context, config);
    if (config.compilerPath && config.compilerPath.trim() !== '') {
        if (!validatePath(compilerPath)) {
            vscode.window.showErrorMessage(`JMCC: Путь к компилятору недействителен: ${compilerPath}`);
            return;
        }
    }
    const args = ['py', `"${compilerPath}"`, 'decompile', `"${path.normalize(targetPath)}"`];
    runCommand(args.join(' '), workspaceFolder);
}

function saveAndUpload(targetPath: string, workspaceFolder: vscode.WorkspaceFolder, context: vscode.ExtensionContext) {
    const config = loadOrInitConfig(workspaceFolder);
    const compilerPath = getCompilerPath(context, config);
    if (config.compilerPath && config.compilerPath.trim() !== '') {
        if (!validatePath(compilerPath)) {
            vscode.window.showErrorMessage(`JMCC: Путь к компилятору недействителен: ${compilerPath}`);
            return;
        }
    }
    const args = ['py', `"${compilerPath}"`, 'compile', `"${path.normalize(targetPath)}"`, '-su'];
    if (config.compilerOutputPath && config.compilerOutputPath.trim() !== '') {
        const normalizedOutputPath = path.normalize(config.compilerOutputPath);
        if (!validatePath(normalizedOutputPath, true)) {
            vscode.window.showErrorMessage(`JMCC: Путь для вывода должен быть файлом: ${normalizedOutputPath}`);
            return;
        }
        args.push('-o', `"${normalizedOutputPath}"`);
    }
    runCommand(args.join(' '), workspaceFolder);
}

export async function activate(context: vscode.ExtensionContext) {
    try {
        await checkAndUpdateAssets(context);
        const serverOptions = getServerOptions(context);
        const clientOptions = getClientOptions();
        client = new LanguageClient(
            'jmccLanguageServer',
            'JMCC Language Server',
            serverOptions,
            clientOptions
        );
        await client.start();
        console.log('JMCC Language Server started');
    } catch (err) {
        vscode.window.showErrorMessage(`JMCC: Ошибка запуска LSP-сервера или проверки обновлений: ${err}`);
    }

    const existingTerminal = vscode.window.terminals.find(t => t.name === TERMINAL_NAME);
    if (existingTerminal) {
        existingTerminal.dispose();
    }

    const commands = [
        vscode.commands.registerCommand('jmcc.compileAsFile', (uri: vscode.Uri) => {
            const folder = getWorkspaceFolder(uri);
            if (folder) compile(uri.fsPath, 'SAVE', folder, context, true);
        }),
        vscode.commands.registerCommand('jmcc.compileAsUrl', (uri: vscode.Uri) => {
            const folder = getWorkspaceFolder(uri);
            if (folder) compile(uri.fsPath, 'UPLOAD', folder, context);
        }),
        vscode.commands.registerCommand('jmcc.decompileFile', (uri: vscode.Uri) => {
            const folder = getWorkspaceFolder(uri);
            if (folder) decompile(uri.fsPath, folder, context);
        }),
        vscode.commands.registerCommand('jmcc.compileActiveFile', () => {
            const active = vscode.window.activeTextEditor?.document;
            if (!active) return;
            if (active.isDirty) active.save();
            const folder = getWorkspaceFolder(active.uri);
            if (folder && active.fileName.endsWith('.jc')) {
                compile(active.fileName, 'SAVE', folder, context);
            }
        }),
        vscode.commands.registerCommand('jmcc.runActiveFile', () => {
            const active = vscode.window.activeTextEditor?.document;
            if (!active) return;
            if (active.isDirty) active.save();
            const filePath = active.fileName;
            const folder = getWorkspaceFolder(active.uri);
            if (!folder) return;
            const config = loadOrInitConfig(folder);
            if (filePath.endsWith('.jc')) {
                const mode = config.defaultCompileActiveFileMode?.toUpperCase() || 'UPLOAD';
                compile(filePath, mode, folder, context);
            } else if (filePath.endsWith('.json')) {
                decompile(filePath, folder, context);
            }
        }),
        vscode.commands.registerCommand('jmcc.saveAndUpload', (uri: vscode.Uri) => {
            const folder = getWorkspaceFolder(uri);
            if (folder) {
                const active = vscode.window.activeTextEditor?.document;
                if (active && active.uri.fsPath === uri.fsPath && active.isDirty) {
                    active.save();
                }
                saveAndUpload(uri.fsPath, folder, context);
            }
        })
    ];
    context.subscriptions.push(...commands);
}

export async function deactivate(): Promise<void> {
    if (client) {
        await client.stop();
        client = undefined;
    }
}